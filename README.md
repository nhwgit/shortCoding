# shortCoding
<img width="703" height="272" alt="image" src="https://github.com/user-attachments/assets/aa4edbe4-d617-4776-8a16-63504713950c" />

https://www.acmicpc.net/short/status/10350
백준 루비티어 문제중에 가장 많이풀린 문제 숏코딩 1등
1. 파이썬으로는 117B 언저리가 한계인 것 같다. 한계가 있으면 도구를 바꿔야지. 그래서 Ruby로 해서 16바이트 줄였다.
2. 온갖 꼼수 많이 써야만한다. 문법상 side-effect도 활용 많이해야하고, 알고리즘 자체를 희한하게 짜야한다.
3. 시간제한에 안걸리는 선에서 최대한 코드를 짧게했다. 예를들어 (i+=1)%n을 i=-~i%n으로 바꾸면 코드는 짧아지지만 시간초과가 발생한다. 아주 미세한 차이지만, 반복문이 1억번씩 돌면서 미세한 차이가 누적되어 시간초과가 발생한 것 같다. 따라서 내부 동작까지 하나하나 신경써가면서 코딩했다. 예를들어 a && b에서 a가 false면 b의 값과 무관하게 a && b가 false다. 따라서 a가 false면 b는 실행되지 않는다. 이런 꼼수를 활용하여 수행시간을 줄이기도 했다.
4. 메이저 언어들처럼 컴파일러 성능만 좋다면 시간제한을 훨씬 덜 신경쓰고 코드를 짤 수 있었을텐데, 컴파일러 성능자체가 너무 안좋은 것 같다. 백준에서 언어에따른 시간제한 보정을 해주긴 하지만.. 그 보정갖고는 부족하다.
5. 어쩌면 지금의 Python자리는 Ruby가 차지했을수도 있다고 생각한다. 두 언어의 생태계가 성숙하지 않았던 20년쯤 전, 두 언어는 경쟁 언어였다. 두 언어 모두 라이브러리도 빈약했고 컴파일러(인터프리터) 성능도 안 좋았다. 그런데, 모종의 이유로 Python이 유행하더니, Python관련 생태계가 성숙해지고 컴파일러(인터프리터) 성능도 점점 좋아졌다. 그러다보니 Python은 더욱 인기가 많아지고, 이는 생태계와 컴파일러 성능에 다시 긍정적인 영향을 주는 루프가 형성됐다.
6. 앞서 언급했듯, Python과 Ruby는 경쟁언어였다. 논의의 단순화를 위해 두 언어의 인기가 1로 동일했다고 하자. 그런데, 모종의 이유로 Python의 인기가 1.01이 됐고, Ruby의 인기가 0.99가 됐다. 그 상태에서 Python은 그 기세를 계속 이어갔고, Ruby는 잘 대응하지 못했다. 그래서 결국 (1.01)^n vs (0.99)^n이 되어, 복리효과로 인해 Python이 Ruby에비해 압도적인 인기를 얻게됐다고 생각한다.
7. 세상에는 복리효과로 설명할 수 있는게 많은 것 같다. 1.01과 같이 "약간 더 신경쓰는 것"혹은 "약간 좋은 것"이 오래 지속되면 그게 (1.01)^1000=20959이 되어 엄청나게 커지는 것 같고, 0.99와 같이 "약간 덜 신경쓰는 것"혹은 "약간 아쉬운 것"이 오래 지속되면, 그 값이 (0.99)^1000=0.00004가 되어 0에 수렴하기도 하는 것 같다.
8. 숏코딩은 극한의 예술이자 스포츠다.
9. 매우 어려울 것 같기는 하다만, Ruby붐이 오기를 바란다.
